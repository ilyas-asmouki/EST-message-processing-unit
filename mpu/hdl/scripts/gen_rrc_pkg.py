#!/usr/bin/env python3
"""
Generate SystemVerilog package with RRC filter coefficients.
"""

import sys
import os
import numpy as np

# Add project root to path to import mpu module
sys.path.append(os.path.join(os.path.dirname(__file__), "../../.."))

from mpu.model.rrc import RRC_COEFFS, SAMPLES_PER_SYMBOL

def main():
    pkg_name = "rrc_pkg"
    file_path = os.path.join(os.path.dirname(__file__), "../rtl/tx_chain/rrc/rrc_pkg.sv")
    
    print(f"Generating {file_path}...")
    
    # Polyphase decomposition
    # h_p[k] = h[4k + p]
    # We need to find the max length of sub-filters
    sub_filters = []
    max_len = 0
    for p in range(SAMPLES_PER_SYMBOL):
        coeffs = RRC_COEFFS[p::SAMPLES_PER_SYMBOL]
        sub_filters.append(coeffs)
        max_len = max(max_len, len(coeffs))
        print(f"Phase {p}: {len(coeffs)} taps")

    # Pad sub-filters to max_len with zeros
    # Note: Padding direction matters. 
    # Convolution is sum(x[m-k] * h[k]). 
    # If we pad h at the end, it corresponds to older symbols (larger k).
    # If we pad h at the beginning, it corresponds to newer symbols.
    # RRC is centered.
    # h[0] is the first tap.
    # Let's just pad at the end for simplicity in the array, but we must be careful in RTL.
    # Actually, let's look at the indices.
    # Phase 0: 0, 4, ..., 40. Length 11.
    # Phase 1: 1, 5, ..., 37. Length 10.
    # Phase 2: 2, 6, ..., 38. Length 10.
    # Phase 3: 3, 7, ..., 39. Length 10.
    
    # If we have a shift register of symbols S[0]...S[10], where S[0] is newest.
    # y = S[0]*h[0] + S[1]*h[1] ...
    # Wait, convolution is usually S[0]*h[0] + S[1]*h[1]... if h is impulse response?
    # y[n] = sum x[n-k] h[k].
    # x[n] is newest. h[0] multiplies newest.
    # So h[0] (index 0 of polyphase) corresponds to the coefficient for the current symbol.
    # h[1] (index 1 of polyphase) corresponds to the previous symbol.
    
    # So for Phase 1 (indices 1, 5...):
    # h_p[0] = h[1]. Multiplies x[n].
    # h_p[1] = h[5]. Multiplies x[n-1].
    # ...
    # h_p[9] = h[37]. Multiplies x[n-9].
    # It stops there.
    # Phase 0 goes up to h[40] (x[n-10]).
    
    # So Phase 0 needs 11 symbols (0 to 10).
    # Phase 1, 2, 3 need 10 symbols (0 to 9).
    # In RTL, we will have a shift register of length 11.
    # For phases 1, 2, 3, the coefficient for the 11th tap (index 10) should be 0.
    
    padded_filters = []
    for p in range(SAMPLES_PER_SYMBOL):
        coeffs = sub_filters[p]
        pad_len = max_len - len(coeffs)
        # Pad at the end (corresponding to older symbols)
        padded = np.pad(coeffs, (0, pad_len), mode='constant')
        padded_filters.append(padded)

    with open(file_path, "w") as f:
        f.write(f"// Generated by mpu/hdl/scripts/gen_rrc_pkg.py\n")
        f.write(f"// Do not edit manually.\n\n")
        f.write(f"package {pkg_name};\n\n")
        
        f.write(f"  localparam int SAMPLES_PER_SYMBOL = {SAMPLES_PER_SYMBOL};\n")
        f.write(f"  localparam int SUB_FILTER_TAPS = {max_len};\n")
        f.write(f"  localparam int COEFF_WIDTH = 18;\n\n")
        
        f.write(f"  // Function to retrieve coefficients\n")
        f.write(f"  function automatic logic signed [COEFF_WIDTH-1:0] get_coeff(input int phase, input int tap);\n")
        f.write(f"    case (phase)\n")
        
        for p in range(SAMPLES_PER_SYMBOL):
            f.write(f"      {p}: begin\n")
            f.write(f"        case (tap)\n")
            coeffs = padded_filters[p]
            for i, c in enumerate(coeffs):
                f.write(f"          {i}: return {int(c)};\n")
            f.write(f"          default: return '0;\n")
            f.write(f"        endcase\n")
            f.write(f"      end\n")
            
        f.write(f"      default: return '0;\n")
        f.write(f"    endcase\n")
        f.write(f"  endfunction\n\n")
        
        f.write(f"endpackage : {pkg_name}\n")

    print("Done.")

if __name__ == "__main__":
    main()
